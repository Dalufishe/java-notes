# 原碼、反碼及補碼

計算機底層運算無法使用數學二進制的那一套含意，因為計算機運算中正負運算須被寫入在 0 1 之內。

數學表示負數: `-`
計算機底層表示負數: `1`

### 原碼

數據`二進制`的表現形式，最左邊是符號位，0 為正，1 為負。

```bash
MAX: 01111111 // 127 (decimal)
min: 11111111 // -127 (decimal)
```

原碼在進行正數運算時沒問題，但當牽扯到負數運算時，會出現錯誤。
另外原碼中 0 和 -0 的定義重複，是不必要的。

```bash
1        + 1        => 預期: 2
00000001 + 00000001 => 原碼運算: 00000010 (2) [O]

-0       + 1        => 預期: 1
10000000 + 00000001 => 原碼運算: 10000001 (-1) [X]

-1       + 1        => 預期: 0
10000001 - 00000001 => 原碼運算: 10000010 (2) [X]

-1       + -1       => 預期: -2
10000001 + 10000001 => 原碼運算: 00000010 (2) [X]
```

### 反碼

為原碼無法進行負數運算而產生。

數據二進制的表現形式，在原碼的基礎上，當正數時反碼不變，負數時，數值取反，0 為 1，1 為 0。

- -56 原碼 : 10111000
- -56 反碼 : 11000111

```bash
1        + 1        => 預期: 2
00000001 + 00000001 => 反碼運算: 00000010 (2) [O]

-1       + 1        => 預期: 0
11111110 + 00000001 => 反碼運算: 11111111 (-0) [O]

```

然而，某些負數計算仍有誤差之情況。

```bash
-1       + -1        => 預期: -2
11111110 + 11111110  => 反碼運算: 11111100 (-3) [X] // 負數之間無法運算

-2       + 3         => 預期: 1
11111101 + 00000011  => 反碼運算: 00000000 (0) [X] // 跨足 0 無法運算
```

### 補碼

將 +0 和 -0 統一，並將負數順一一位。

````bash
-1       + -1        => 預期: -2
11111111 + 11111111  => 補碼運算: 11111110 (-2) [O]

-2       + 3         => 預期: 1
11111110 + 00000011  => 補碼運算: 00000001 (1) [O]
```
````

使用補碼二進位表示形式，就能夠正確地進行正/負數數學運算。
因此，電腦底層的運算及存儲均符合補碼規則(符合數學邏輯的)。

補碼節省了一位 0，因此範圍為 (-128 ~ 127)。

### 總結

- 原碼
  - 最左邊是符號位，0 為正、1 為負。
  - 負數運算結果是錯的。
  - 範圍 -127 ~ 127。
- 反碼 (基於原碼)
  - 最左邊是符號位，0 為正、1 為負。
  - 負數時，數值取反，0 換 1、1 換 0。
  - 負數運算結果仍有時是錯的。(0, -0 問題)。
  - - 範圍 -127 ~ 127。
- 補碼 (基於反碼)
  - 最左邊是符號位，0 為正、1 為負。
  - 負數時，數值取反，0 換 1、1 換 0。
  - 將 +0 和 -0 統一，並將負數順一一位。
  - 可正常進行數學運算，是電腦底層的二進制規則。
  - 範圍 -128 ~ 127。

### Java 中應用場景

#### 數據類型

- byte
  - 佔 1 byte，0000 0001 // 1 在記憶體中使用 byte 存儲 (補碼)
- short
  - 佔 2 bytes，0000 0000 0000 0001 // 1 在記憶體中使用 short 存儲 (補碼)
- int
  - 佔 4 bytes，0000 0000 0000 0000 0000 0000 0000 0001 // 1 在記憶體中使用 int 存儲 (補碼)
- long
  - 佔 8 bytes，0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001 // 1 在記憶體中使用 long 存儲 (補碼)

#### 小轉大、大轉小

- 存儲範圍小轉存儲範圍大

```java
byte b = 3; // 0000 0011 =>
int i = b; // 0000 0000 0000 0000 0000 0000 0000 0011
```

- 存儲範圍大轉存儲範圍小

```java
int i = 300; // 0000 0000 0000 0000 0000 0001 0011 1100
byte b = (byte) i; // 0011 1100
```

#### 邏輯 &, |, >>, <<, >>>

### 且 &

`&` 用於計算數字時(非 boolean)，拿來做底層`二進位`數據的`與`計算。

### 或 |

`|` 用於計算數字時(非 boolean)，拿來做底層`二進位`數據的`或`計算。

### 左移 <<

`>>` 用於計算數字，拿來做底層`二進位`數據的`左移`計算。(並在低位補 0)

### 右移 >>

`<<` 用於計算數字，拿來做底層`二進位`數據的`右移`計算。(並在高位補 0 或 1)

### 無符號右移 >>>

`>>>` 用於計算數字，拿來做底層`二進位`數據的`右移`計算。(並在高位補 0)
